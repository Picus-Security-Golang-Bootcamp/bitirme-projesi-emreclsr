<!DOCTYPE html>
<!-- saved from url=(0076)file:///C:/Users/emrec/AppData/Local/Temp/cover755617350/coverage.html#file7 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
		<title>authentication: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/emreclsr/picusfinal/authentication/loginhandler.go (58.3%)</option>
				
				<option value="file1">github.com/emreclsr/picusfinal/authentication/signuphandler.go (52.6%)</option>
				
				<option value="file2">github.com/emreclsr/picusfinal/authentication/token.go (27.3%)</option>
				
				<option value="file3">github.com/emreclsr/picusfinal/basket/basket.go (81.8%)</option>
				
				<option value="file4">github.com/emreclsr/picusfinal/basket/handler.go (47.3%)</option>
				
				<option value="file5">github.com/emreclsr/picusfinal/basket/repository.go (100.0%)</option>
				
				<option value="file6">github.com/emreclsr/picusfinal/basket/service.go (100.0%)</option>
				
				<option value="file7">github.com/emreclsr/picusfinal/category/handler.go (57.6%)</option>
				
				<option value="file8">github.com/emreclsr/picusfinal/category/repository.go (76.5%)</option>
				
				<option value="file9">github.com/emreclsr/picusfinal/category/service.go (69.2%)</option>
				
				<option value="file10">github.com/emreclsr/picusfinal/order/handler.go (53.5%)</option>
				
				<option value="file11">github.com/emreclsr/picusfinal/order/order.go (100.0%)</option>
				
				<option value="file12">github.com/emreclsr/picusfinal/order/repository.go (82.6%)</option>
				
				<option value="file13">github.com/emreclsr/picusfinal/order/service.go (61.9%)</option>
				
				<option value="file14">github.com/emreclsr/picusfinal/product/handler.go (42.7%)</option>
				
				<option value="file15">github.com/emreclsr/picusfinal/product/repository.go (74.2%)</option>
				
				<option value="file16">github.com/emreclsr/picusfinal/product/service.go (54.5%)</option>
				
				<option value="file17">github.com/emreclsr/picusfinal/user/repository.go (75.0%)</option>
				
				<option value="file18">github.com/emreclsr/picusfinal/user/service.go (0.0%)</option>
				
				<option value="file19">github.com/emreclsr/picusfinal/user/user.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none;">package authentication

import (
        "github.com/emreclsr/picusfinal/user"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
        "net/http"
)

type Authenticate struct {
        userService user.UserService
        token       TokenInterface
}
type IAuthenticate interface {
        Login(c *gin.Context)
}

// NewAuthenticate creates a new Authenticate object (constructor)
func NewAuthenticate(usrSrv user.UserService, tk TokenInterface) IAuthenticate <span class="cov8" title="1">{
        return &amp;Authenticate{userService: usrSrv, token: tk}
}</span>

var _ IAuthenticate = &amp;Authenticate{}

func (au *Authenticate) Login(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("Login triggered")
        var usr user.User
        err := c.ShouldBindJSON(&amp;usr)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error binding JSON while logging in")
                c.JSON(http.StatusUnprocessableEntity, "Invalid JSON provided for login")
        }</span>
        <span class="cov8" title="1">u, usrErr := au.userService.GetByEmail(usr.Email)
        if usrErr != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error getting user while logging in")
                c.JSON(http.StatusInternalServerError, usrErr)
        }</span>
        // Password check
        <span class="cov8" title="1">errPass := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(usr.Password))
        if errPass != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error comparing password while logging in")
                c.JSON(http.StatusUnauthorized, "Username or password is incorrect")
        }</span>
        // Email check
        <span class="cov8" title="1">if usr.Email != u.Email </span><span class="cov0" title="0">{
                zap.L().Error("Error comparing email while logging in")
                c.JSON(http.StatusUnauthorized, "Username or password is incorrect")
        }</span>
        <span class="cov8" title="1">tkstring, tknErr := au.token.CreateToken(u)
        if tknErr != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error creating token while logging in")
                c.JSON(http.StatusInternalServerError, tknErr)
        }</span>
        <span class="cov8" title="1">c.SetCookie("TokenJWT", tkstring, 60*60*24, "/", "localhost", false, true)
        c.JSON(http.StatusOK, "Logged in successfully")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none;">package authentication

import (
        "github.com/emreclsr/picusfinal/user"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "net/http"
)

type Users struct {
        userServ user.UserService
}
type IUsers interface {
        SignUp(c *gin.Context)
}

var _ IUsers = &amp;Users{}

// NewUsers creates a new Users object (constructor)
func NewUsers(usrService user.UserService) IUsers <span class="cov8" title="1">{

        return &amp;Users{userServ: usrService}
}</span>

func (u *Users) SignUp(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("SignUp triggered")
        var usr user.User

        err := c.ShouldBindJSON(&amp;usr)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error binding JSON while signing up")
                c.JSON(http.StatusUnprocessableEntity, "Invalid JSON provided for signup")
                return
        }</span>
        <span class="cov8" title="1">check, _ := u.userServ.GetByEmail(usr.Email)
        if check != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while getting email in sing up")
                c.JSON(http.StatusConflict, "User already exists")
                return
        }</span>

        <span class="cov8" title="1">err = u.userServ.Create(&amp;usr)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error signing up create")
                c.JSON(http.StatusInternalServerError, "Server error")
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusCreated, usr)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package authentication

import (
        "fmt"
        "github.com/emreclsr/picusfinal/user"
        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt"
        "go.uber.org/zap"
        "os"
        "time"
)

type Token struct {
        UserID uint
        Role   string
        jwt.StandardClaims
}

type TokenInterface interface {
        CreateToken(usr *user.User) (string, error)
        VerifyToken(r *gin.Context) (*Token, error)
}

// Compile time proof of interface implementation
var _ TokenInterface = &amp;Token{}

func NewToken() TokenInterface <span class="cov8" title="1">{
        return &amp;Token{}
}</span>

func (t *Token) CreateToken(usr *user.User) (string, error) <span class="cov8" title="1">{
        token := &amp;Token{
                UserID: usr.ID,
                Role:   usr.Role,
        }
        token.ExpiresAt = time.Now().Add(time.Hour * 1).Unix()
        at, err := jwt.NewWithClaims(jwt.SigningMethodHS256, token).SignedString([]byte(os.Getenv("SECRET_KEY")))
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while creating token")
                return "", err
        }</span>
        <span class="cov8" title="1">return at, nil</span>
}

func (t *Token) VerifyToken(r *gin.Context) (*Token, error) <span class="cov0" title="0">{
        var claim = &amp;Token{}
        cookie, err := r.Request.Cookie("TokenJWT")
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while getting cookie (verify token)")
                return nil, err
        }</span>
        <span class="cov0" title="0">tokenStr := cookie.Value
        token, err := jwt.ParseWithClaims(tokenStr, claim, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(os.Getenv("SECRET_KEY")), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while parsing token (verify token)")
                return nil, err
        }</span>
        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Token is not valid")
        }</span>
        <span class="cov0" title="0">return claim, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package basket

import (
        "errors"
        "github.com/emreclsr/picusfinal/order"
        "github.com/emreclsr/picusfinal/product"
        "github.com/emreclsr/picusfinal/user"
        "github.com/lib/pq"
        "go.uber.org/zap"
        "gorm.io/gorm"
        "os"
        "strconv"
)

type Basket struct {
        gorm.Model
        User       user.User         `json:"user"`
        UserID     uint              `json:"user_id"`
        ProductIds pq.Int64Array     `json:"product_ids" gorm:"type:integer[]"`
        Products   []product.Product `json:"products" gorm:"-"`
        Amount     pq.Int64Array     `json:"amount" gorm:"type:integer[]"`
        TotalPrice float64           `json:"total_price"`
}

func (b *Basket) CalculateTotalPrice() <span class="cov8" title="1">{
        for i, v := range b.Amount </span><span class="cov8" title="1">{
                b.TotalPrice += float64(v) * b.Products[i].Price
        }</span>
}

func (b *Basket) CalculateLineTotal() pq.Float64Array <span class="cov8" title="1">{
        var lineTotal []float64
        for i, v := range b.Amount </span><span class="cov8" title="1">{
                lineTotal = append(lineTotal, float64(v)*b.Products[i].Price)
        }</span>
        <span class="cov8" title="1">return pq.Float64Array(lineTotal)</span>
}

func (b *Basket) ToOrder() *order.Order <span class="cov8" title="1">{
        o := order.Order{
                UserID:     b.UserID,
                User:       b.User,
                TotalPrice: b.TotalPrice,
                IsCanceled: false,
                Amount:     b.Amount,
                LineTotal:  b.CalculateLineTotal(),
                ProductIds: b.ProductIds,
                Products:   b.Products,
        }
        return &amp;o
}</span>

func (b *Basket) CheckItemsCountAndBasketQuantity() (bool, error) <span class="cov8" title="1">{
        maxItem, err := strconv.Atoi(os.Getenv("MAX_ITEM_PER_BASKET"))
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while converting MAX_ITEM_PER_BASKET to int", zap.Error(err))
                return false, err
        }</span>
        <span class="cov8" title="1">if len(b.ProductIds) &gt; maxItem </span><span class="cov8" title="1">{

                return false, errors.New("max item limit exceeded")
        }</span>

        <span class="cov8" title="1">maxAmount, err := strconv.Atoi(os.Getenv("MAX_QTY_PER_PRODUCT"))
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while converting MAX_AMOUNT_OF_ITEM to int", zap.Error(err))
                return false, err
        }</span>
        <span class="cov8" title="1">for _, v := range b.Amount </span><span class="cov8" title="1">{
                if v &gt; int64(maxAmount) </span><span class="cov8" title="1">{
                        return false, errors.New("max amount limit exceeded")
                }</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package basket

import (
        "github.com/emreclsr/picusfinal/authentication"
        "github.com/emreclsr/picusfinal/order"
        "github.com/emreclsr/picusfinal/product"
        "github.com/emreclsr/picusfinal/user"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "net/http"
)

type BasketHandler struct {
        basketServ  BasketService
        token       authentication.TokenInterface
        userServ    user.UserService
        orderServ   order.OrderService
        productServ product.ProductService
}
type IBasketHandler interface {
        UpdateBasket(c *gin.Context)
        GetBasket(c *gin.Context)
        CreateAnOrder(c *gin.Context)
}

var _ IBasketHandler = &amp;BasketHandler{}

func NewBasketHandler(bs BasketService, token authentication.TokenInterface, userServ user.UserService, orderServ order.OrderService, productServ product.ProductService) IBasketHandler <span class="cov8" title="1">{
        return &amp;BasketHandler{
                basketServ:  bs,
                token:       token,
                userServ:    userServ,
                orderServ:   orderServ,
                productServ: productServ,
        }
}</span>

func (h *BasketHandler) UpdateBasket(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("Update basket handler triggered")
        claims, err := h.token.VerifyToken(c)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while verifying token in update basket handler", zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized for this action"})
        }</span>
        <span class="cov8" title="1">var basket Basket

        err = c.ShouldBindJSON(&amp;basket)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while binding json in update basket handler", zap.Error(err))
                c.JSON(http.StatusUnprocessableEntity, gin.H{"error": err.Error()})
                return
        }</span>

        // If basket not created yet, create one
        <span class="cov8" title="1">bskt, err := h.basketServ.GetByUserId(claims.UserID)
        if bskt.ID == 0 </span><span class="cov8" title="1">{
                err = h.basketServ.CreateBasket(claims.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        zap.L().Error("Error while creating basket in update basket handler", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while getting basket by user id in update basket handler", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">basket.UserID = claims.UserID

        for key, id := range basket.ProductIds </span><span class="cov8" title="1">{
                p, errs := h.productServ.Get(uint(id))
                if errs != nil </span><span class="cov0" title="0">{
                        zap.L().Error("Error while getting product in update basket handler", zap.Error(errs))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov8" title="1">if int64(p.Stock)-basket.Amount[key] &lt; 0 </span><span class="cov0" title="0">{
                        zap.L().Error("Not enough stock in update basket handler")
                        c.JSON(http.StatusUnprocessableEntity, gin.H{"error": "Not enough stock from product with name" + p.Name})
                        return
                }</span>
                <span class="cov8" title="1">basket.Products = append(basket.Products, *p)</span>
        }
        <span class="cov8" title="1">basket.CalculateTotalPrice()

        if err := h.basketServ.UpdateBasket(&amp;basket); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while updating basket in update basket handler", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"status": "item added successfully"})</span>
}

func (h *BasketHandler) GetBasket(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("Get basket handler triggered")
        claims, err := h.token.VerifyToken(c)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while verifying token in get basket handler", zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized for this action"})
                return
        }</span>
        // If basket not created yet, create one
        <span class="cov8" title="1">basket, err := h.basketServ.GetByUserId(claims.UserID)
        if basket.ID == 0 </span><span class="cov8" title="1">{
                //err = h.basketServ.CreateBasket(claims.UserID)
                //if err != nil {
                //        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                //        return
                //}
                c.JSON(http.StatusOK, gin.H{"message": "basket is empty"})
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                zap.L().Error("Error while getting basket by user id in get basket handler", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">if len(basket.ProductIds) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"message": "basket is empty"})
                return
        }</span>
        <span class="cov0" title="0">for _, id := range basket.ProductIds </span><span class="cov0" title="0">{
                p, errs := h.productServ.Get(uint(id))
                if errs != nil </span><span class="cov0" title="0">{
                        zap.L().Error("Error while getting product in get basket handler", zap.Error(errs))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">basket.Products = append(basket.Products, *p)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"basket": basket})</span>
}

func (h *BasketHandler) CreateAnOrder(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("Create order handler triggered")
        claims, err := h.token.VerifyToken(c)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while verifying token in create order handler", zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized for this action"})
                return
        }</span>
        <span class="cov8" title="1">basket, err := h.basketServ.GetByUserId(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while getting basket by user id in create order handler", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">for key, id := range basket.ProductIds </span><span class="cov8" title="1">{
                p, errs := h.productServ.Get(uint(id))
                if errs != nil </span><span class="cov0" title="0">{
                        zap.L().Error("Error while getting product in create order handler", zap.Error(errs))
                        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov8" title="1">p.Stock = p.Stock - int(basket.Amount[key])
                err := h.productServ.Update(p)
                if err != nil </span><span class="cov0" title="0">{
                        zap.L().Error("Error while updating product in create order handler", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov8" title="1">basket.Products = append(basket.Products, *p)</span>
        }

        // Check permitted items count and amount in basket
        <span class="cov8" title="1">status, err := basket.CheckItemsCountAndBasketQuantity()
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while checking items in create order handler", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">if status == false </span><span class="cov0" title="0">{
                zap.L().Error("Error while checking items amount in create order handler")
                c.JSON(http.StatusBadRequest, gin.H{"error": err})
                return
        }</span>

        <span class="cov8" title="1">o := basket.ToOrder()
        err = h.orderServ.Create(o)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while creating order in create order handler", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">emptyBasket := &amp;Basket{UserID: claims.UserID}
        if err := h.basketServ.UpdateBasket(emptyBasket); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while updating basket in create order handler", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"order": o})</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none;">package basket

import (
        "go.uber.org/zap"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type repository struct {
        db *gorm.DB
}

type BasketRepository interface {
        Create(userId uint) error
        Update(basket *Basket) error
        GetByUserId(userId uint) (*Basket, error)
}

// Compile time proof of interface implementation
var _ BasketRepository = &amp;repository{}

func NewBasketRepository(db *gorm.DB) BasketRepository <span class="cov8" title="1">{
        return &amp;repository{db: db}
}</span>

func (r *repository) Create(userId uint) error <span class="cov8" title="1">{
        zap.L().Info("Create basket (repository)")
        basket := Basket{UserID: userId}
        return r.db.Preload(clause.Associations).Create(&amp;basket).Error
}</span>

func (r *repository) Update(basket *Basket) error <span class="cov8" title="1">{
        zap.L().Info("Update basket (repository)")
        return r.db.Preload(clause.Associations).Where("user_id = ?", basket.UserID).Save(&amp;basket).Error
}</span>

func (r *repository) GetByUserId(userId uint) (*Basket, error) <span class="cov8" title="1">{
        zap.L().Info("Get basket by user id (repository)")
        basket := &amp;Basket{}
        err := r.db.Preload(clause.Associations).First(&amp;basket).Error
        return basket, err
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none;">package basket

import "go.uber.org/zap"

type basketService struct {
        repo BasketRepository
}

type BasketService interface {
        CreateBasket(userId uint) error
        UpdateBasket(basket *Basket) error
        GetByUserId(userId uint) (*Basket, error)
}

// Compile time proof of interface implementation
var _ BasketService = &amp;basketService{}

func NewBasketService(repo BasketRepository) BasketService <span class="cov8" title="1">{

        return &amp;basketService{repo: repo}
}</span>

func (s *basketService) CreateBasket(userId uint) error <span class="cov8" title="1">{
        zap.L().Info("Create basket service triggered")
        return s.repo.Create(userId)
}</span>

func (s *basketService) UpdateBasket(basket *Basket) error <span class="cov8" title="1">{
        zap.L().Info("Update basket service triggered")
        return s.repo.Update(basket)
}</span>

func (s *basketService) GetByUserId(userId uint) (*Basket, error) <span class="cov8" title="1">{
        zap.L().Info("Get basket service triggered")
        return s.repo.GetByUserId(userId)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: block;">package category

import (
        "encoding/csv"
        "github.com/emreclsr/picusfinal/authentication"
        "github.com/emreclsr/picusfinal/product"
        "github.com/gin-gonic/gin"
        set "github.com/mpvl/unique"
        "go.uber.org/zap"
        "net/http"
        "sort"
        "strconv"
)

type CategoryHandler struct {
        catServ     CategoryService
        token       authentication.TokenInterface
        productServ product.ProductService
}
type ICategoryHandler interface {
        GetAllCategories(c *gin.Context)
        CreateCategoryFromCSV(c *gin.Context)
}

var _ ICategoryHandler = &amp;CategoryHandler{}

func NewCategoryHandler(catServ CategoryService, token authentication.TokenInterface, productServ product.ProductService) ICategoryHandler <span class="cov8" title="1">{
        return &amp;CategoryHandler{
                catServ:     catServ,
                token:       token,
                productServ: productServ,
        }
}</span>

func (h *CategoryHandler) GetAllCategories(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("GetAllCategories handler triggered")
        categories, err := h.catServ.List()
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while getting categories (handler)", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, categories)</span>
}

func (h *CategoryHandler) CreateCategoryFromCSV(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("CreateCategoryFromCSV handler triggered")
        claim, err := h.token.VerifyToken(c)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while verifying token in create category from csv", zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">if claim.Role != "admin" </span><span class="cov0" title="0">{
                zap.L().Error("Non admin user tried to create category from csv", zap.String("user", claim.Role))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized to perform this action"})
                return
        }</span>
        <span class="cov8" title="1">csvPartFile, _, openErr := c.Request.FormFile("csv")
        if openErr != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while opening csv file", zap.Error(openErr))
                c.JSON(http.StatusBadRequest, gin.H{"error": openErr.Error()})
                return
        }</span>
        <span class="cov8" title="1">csvLines, readErr := csv.NewReader(csvPartFile).ReadAll()
        if readErr != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while reading csv file", zap.Error(readErr))
                c.JSON(http.StatusBadRequest, gin.H{"error": readErr.Error()})
                return
        }</span>
        <span class="cov8" title="1">var catList []string
        var product product.Product

        for i, each := range csvLines </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        catList = append(catList, each[0])
                        product.Name = each[1]
                        p, err := strconv.ParseFloat(each[2], 64)
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                                return
                        }</span>
                        <span class="cov8" title="1">product.Price = p
                        ps, err := strconv.Atoi(each[3])
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                                return
                        }</span>
                        <span class="cov8" title="1">product.Stock = ps
                        product.Type = each[4]

                        if err := h.productServ.Create(&amp;product); err != nil </span><span class="cov0" title="0">{
                                zap.L().Error("Error while creating product (handler)", zap.Error(err))
                                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                                return
                        }</span>
                        <span class="cov8" title="1">product.ID = 0</span>
                }
        }

        <span class="cov8" title="1">sort.Strings(catList)
        set.Strings(&amp;catList)
        for _, i := range catList </span><span class="cov8" title="1">{
                category := Category{
                        Type: i,
                }
                if err := h.catServ.Create(&amp;category); err != nil </span><span class="cov0" title="0">{
                        zap.L().Error("Error while creating category (handler)", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>
        }
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Categories created successfully"})</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package category

import (
        "go.uber.org/zap"
        "gorm.io/gorm"
)

type CategoryRepository interface {
        Create(category *Category) error
        List() ([]Category, error)
}

type repository struct {
        db *gorm.DB
}

// Compile time proof of interface implementation
var _ CategoryRepository = &amp;repository{}

func NewCategoryRepository(db *gorm.DB) CategoryRepository <span class="cov8" title="1">{
        return &amp;repository{db: db}
}</span>

func (r *repository) Create(category *Category) error <span class="cov8" title="1">{
        zap.L().Info("Create category (repository)")
        catType := category.Type
        rowsAffected := r.db.Where("type = ?", catType).Updates(&amp;category).RowsAffected
        if rowsAffected == 0 </span><span class="cov8" title="1">{
                err := r.db.Create(category).Error
                if err != nil </span><span class="cov0" title="0">{
                        zap.L().Error("Create category error (repository)", zap.Error(err))
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *repository) List() ([]Category, error) <span class="cov8" title="1">{
        zap.L().Info("List categories (repository)")
        var categories []Category
        //Find: get all IsDelete false rows
        err := r.db.Find(&amp;categories, "deleted_at is null").Error
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("List categories error (repository)", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">return categories, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package category

import "go.uber.org/zap"

type categoryService struct {
        repo CategoryRepository
}

type CategoryService interface {
        Create(category *Category) error
        List() ([]Category, error)
}

// Compile time proof of interface implementation
var _ CategoryService = &amp;categoryService{}

func NewCategoryService(repo CategoryRepository) CategoryService <span class="cov8" title="1">{
        return &amp;categoryService{repo: repo}
}</span>

func (s *categoryService) Create(category *Category) error <span class="cov8" title="1">{
        zap.L().Info("Creating category service triggered")
        err := s.repo.Create(category)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error creating category (service)", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *categoryService) List() ([]Category, error) <span class="cov8" title="1">{
        zap.L().Info("Listing category service triggered")
        categories, err := s.repo.List()
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error listing category (service)", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">return categories, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package order

import (
        "github.com/emreclsr/picusfinal/authentication"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "net/http"
        "strconv"
)

type OrderHandler struct {
        orderServ OrderService
        token     authentication.TokenInterface
}
type IOrderHandler interface {
        GetOrders(c *gin.Context)
        CancelOrder(c *gin.Context)
}

var _ IOrderHandler = &amp;OrderHandler{}

func NewOrderHandler(orderServ OrderService, token authentication.TokenInterface) IOrderHandler <span class="cov8" title="1">{
        return &amp;OrderHandler{orderServ, token}
}</span>

func (h *OrderHandler) GetOrders(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("GetOrders handler triggered")
        claim, err := h.token.VerifyToken(c)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Token verification failed in get orders handler", zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">orders, err := h.orderServ.List(claim.UserID)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while getting orders handler", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, orders)</span>
}

func (h *OrderHandler) CancelOrder(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("CancelOrder handler triggered")
        claim, err := h.token.VerifyToken(c)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while verifying token in cancel order handler", zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">orderId := c.Param("id")
        oid, err := strconv.Atoi(orderId)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">order, err := h.orderServ.Get(uint(oid))
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while getting order in cancel order handler", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">if order.UserID != claim.UserID </span><span class="cov0" title="0">{
                zap.L().Error("User is not authorized to cancel order", zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized to cancel this order"})
                return
        }</span>
        <span class="cov8" title="1">if !order.CheckTime() </span><span class="cov8" title="1">{
                zap.L().Error("Order can not be canceled", zap.Error(err))
                c.JSON(http.StatusBadRequest, gin.H{"error": "You can not cancel this order because it is not in the time limit"})
                return
        }</span>
        <span class="cov8" title="1">order.IsCanceled = true

        if err := h.orderServ.Update(order); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error while updating order in cancel order handler", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"status": "Order canceled"})</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package order

import (
        "github.com/emreclsr/picusfinal/product"
        "github.com/emreclsr/picusfinal/user"
        "github.com/lib/pq"
        "gorm.io/gorm"
        "time"
)

type Order struct {
        gorm.Model
        UserID     uint              `json:"user_id"`
        User       user.User         `json:"user" gorm:"foreignkey:UserID"`
        TotalPrice float64           `json:"total_price"`
        IsCanceled bool              `json:"is_canceled"`
        Amount     pq.Int64Array     `json:"amount" gorm:"type:integer[]"`
        LineTotal  pq.Float64Array   `json:"line_total" gorm:"type:float[]"`
        ProductIds pq.Int64Array     `json:"product_ids" gorm:"type:integer[]"`
        Products   []product.Product `json:"products" gorm:"many2many:order_products;association_foreignkey:ID;foreignkey:ID"`
}

func (o *Order) CheckTime() bool <span class="cov8" title="1">{
        duration := time.Duration(14 * 24 * time.Hour)
        if o.CreatedAt.Add(duration).After(time.Now()) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package order

import (
        "go.uber.org/zap"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type OrderRepository interface {
        Create(order *Order) error
        Get(id uint) (*Order, error)
        List(userID uint) ([]Order, error)
        Update(order *Order) error
}

type repository struct {
        db *gorm.DB
}

// Compile time proof of interface implementation
var _ OrderRepository = &amp;repository{}

func NewOrderRepository(db *gorm.DB) OrderRepository <span class="cov8" title="1">{
        return &amp;repository{db: db}
}</span>

func (r *repository) Create(order *Order) error <span class="cov8" title="1">{
        zap.L().Info("Creating order")
        err := r.db.Create(order).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *repository) Get(id uint) (*Order, error) <span class="cov8" title="1">{
        zap.L().Info("Getting order", zap.Uint("id", id))
        var order Order
        err := r.db.Preload(clause.Associations).Where("id = ?", id).First(&amp;order).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;order, nil</span>
}

func (r *repository) List(userID uint) ([]Order, error) <span class="cov8" title="1">{
        zap.L().Info("Listing orders", zap.Uint("userID", userID))
        var orders []Order
        err := r.db.Preload(clause.Associations).Where("user_id = ?", userID).Find(&amp;orders).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return orders, nil</span>
}

func (r *repository) Update(order *Order) error <span class="cov8" title="1">{
        zap.L().Info("Updating order", zap.Reflect("order", order))
        err := r.db.Save(order).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package order

import "go.uber.org/zap"

type orderService struct {
        repo OrderRepository
}

type OrderService interface {
        Create(order *Order) error
        Get(id uint) (*Order, error)
        List(userID uint) ([]Order, error)
        Update(order *Order) error
}

func NewOrderService(repo OrderRepository) OrderService <span class="cov8" title="1">{
        return &amp;orderService{repo: repo}
}</span>

// Compile time proof of interface implementation
var _ OrderService = &amp;orderService{}

func (s *orderService) Create(order *Order) error <span class="cov0" title="0">{
        zap.L().Info("Create order service triggered")
        err := s.repo.Create(order)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *orderService) Get(id uint) (*Order, error) <span class="cov8" title="1">{
        zap.L().Info("Get order service triggered")
        order, err := s.repo.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return order, nil</span>
}

func (s *orderService) List(userID uint) ([]Order, error) <span class="cov8" title="1">{
        zap.L().Info("List order service triggered")
        orders, err := s.repo.List(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return orders, nil</span>
}

func (s *orderService) Update(order *Order) error <span class="cov8" title="1">{
        zap.L().Info("Update order service triggered")
        err := s.repo.Update(order)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package product

import (
        "github.com/emreclsr/picusfinal/authentication"
        "github.com/emreclsr/picusfinal/pagination"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "net/http"
        "strconv"
)

type ProductHandler struct {
        ProductService ProductService
        token          authentication.TokenInterface
}
type IProductHandler interface {
        CreateProduct(c *gin.Context)
        GetProducts(c *gin.Context)
        Search(c *gin.Context)
        DeleteProduct(c *gin.Context)
        UpdateProduct(c *gin.Context)
}

var _ IProductHandler = &amp;ProductHandler{}

func NewProductHandler(service ProductService, token authentication.TokenInterface) *ProductHandler <span class="cov8" title="1">{
        return &amp;ProductHandler{
                ProductService: service,
                token:          token,
        }
}</span>

func (h *ProductHandler) CreateProduct(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("CreateProduct handler triggered")
        claim, err := h.token.VerifyToken(c)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Token verification failed in create product handler", zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized to perform this action"})
                return
        }</span>
        <span class="cov8" title="1">if claim.Role != "admin" </span><span class="cov0" title="0">{
                zap.L().Error("Non admin user tried to create product", zap.String("user", claim.Role))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized to perform this action"})
                return
        }</span>
        <span class="cov8" title="1">var product Product
        if err := c.ShouldBindJSON(&amp;product); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error in binding json in create product handler", zap.Error(err))
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">if err := h.ProductService.Create(&amp;product); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error in creating product (handler)", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusCreated, product)</span>
}

//func (h *ProductHandler) GetProducts(c *gin.Context) {
//        zap.L().Info("GetProducts handler triggered")
//        _, err := h.token.VerifyToken(c)
//        if err != nil {
//                zap.L().Error("Token verification failed in get products handler", zap.Error(err))
//                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
//                return
//        }
//        products, err := h.ProductService.List()
//        if err != nil {
//                zap.L().Error("Error in getting products (handler)", zap.Error(err))
//                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
//                return
//        }
//
//        c.JSON(http.StatusOK, products)
//}

func (h *ProductHandler) GetProducts(c *gin.Context) <span class="cov8" title="1">{
        pg := pagination.GeneratePaginationRequest(c)
        pg.URLPath = c.Request.URL.Path
        pagi, err := h.ProductService.List(pg)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, pagi)</span>
}

func (h *ProductHandler) Search(c *gin.Context) <span class="cov0" title="0">{
        zap.L().Info("Search product handler triggered")
        word := c.Param("word")
        products, err := h.ProductService.Search(word)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error in searching product (handler)", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, products)</span>
}

func (h *ProductHandler) DeleteProduct(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("DeleteProduct handler triggered")
        claim, err := h.token.VerifyToken(c)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Token verification failed in delete product handler", zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized to perform this action"})
                return
        }</span>
        <span class="cov8" title="1">if claim.Role != "admin" </span><span class="cov0" title="0">{
                zap.L().Error("Non admin user tried to delete product", zap.String("user", claim.Role))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized to perform this action"})
                return
        }</span>
        <span class="cov8" title="1">idParam := c.Param("id")
        id, err := strconv.Atoi(idParam)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">if err := h.ProductService.Delete(uint(id)); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error in deleting product (handler)", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Product deleted"})</span>
}

func (h *ProductHandler) UpdateProduct(c *gin.Context) <span class="cov8" title="1">{
        zap.L().Info("UpdateProduct handler triggered")
        claim, err := h.token.VerifyToken(c)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Token verification failed in update product handler", zap.Error(err))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized to perform this action"})
                return
        }</span>
        <span class="cov8" title="1">if claim.Role != "admin" </span><span class="cov0" title="0">{
                zap.L().Error("Non admin user tried to update product", zap.String("user", claim.Role))
                c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized to perform this action"})
                return
        }</span>
        <span class="cov8" title="1">idParam := c.Param("id")
        id, err := strconv.Atoi(idParam)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">var product Product
        if err := c.ShouldBindJSON(&amp;product); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error in binding json to product (handler)", zap.Error(err))
                c.JSON(http.StatusUnprocessableEntity, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">product.ID = uint(id)
        if err := h.ProductService.Update(&amp;product); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error in updating product (handler)", zap.Error(err))
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov8" title="1">c.JSON(http.StatusOK, product)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package product

import (
        "github.com/emreclsr/picusfinal/pagination"
        "go.uber.org/zap"
        "gorm.io/gorm"
        "math"
)

type ProductRepository interface {
        Create(product *Product) error
        Search(word string) ([]Product, error)
        Delete(id uint) error
        Update(product *Product) error
        //List() ([]Product, error)
        List(pg *pagination.Pagination) (*pagination.Pagination, error)
        Get(id uint) (*Product, error)
}

type repository struct {
        db *gorm.DB
}

// Compile time proof of interface implementation
var _ ProductRepository = &amp;repository{}

func NewProductRepository(db *gorm.DB) ProductRepository <span class="cov8" title="1">{
        return &amp;repository{db: db}
}</span>

func (r *repository) Create(product *Product) error <span class="cov8" title="1">{
        zap.L().Info("Create product")
        err := r.db.Create(&amp;product).Error
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Create product error (repository)", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *repository) Search(word string) ([]Product, error) <span class="cov8" title="1">{
        zap.L().Info("Searching for products", zap.String("word", word))
        var products []Product
        err := r.db.Where("name LIKE ?", "%"+word+"%").Find(&amp;products).Error
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Searching for products error (repository)", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">return products, nil</span>
}

func (r *repository) Delete(id uint) error <span class="cov8" title="1">{
        zap.L().Info("Deleting product", zap.Uint("id", id))
        err := r.db.Where("id = ?", id).Delete(&amp;Product{}).Error
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Deleting product error (repository)", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *repository) Update(product *Product) error <span class="cov8" title="1">{
        zap.L().Info("Updating product", zap.Reflect("product", product))
        err := r.db.Save(&amp;product).Error
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Updating product error (repository)", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//func (r *repository) List() ([]Product, error) {
//        zap.L().Info("Listing products")
//        var products []Product
//        err := r.db.Find(&amp;products).Error
//        if err != nil {
//                zap.L().Error("Listing products error (repository)", zap.Error(err))
//                return nil, err
//        }
//        return products, nil
//}

//type RepositoryResult struct {
//        Result interface{}
//        Error  error
//}

func (r *repository) List(pg *pagination.Pagination) (*pagination.Pagination, error) <span class="cov8" title="1">{
        zap.L().Info("Listing products")
        var products []Product

        var totalRows int64 = 0
        var fromRow int64 = 0
        var toRow int64 = 0

        offset := pg.Page * pg.Limit

        // get data with limit, offset &amp; order
        err := r.db.Limit(pg.Limit).Offset(offset).Order(pg.Sort).Find(&amp;products).Error
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Listing products error (repository)", zap.Error(err))
                return &amp;pagination.Pagination{}, err
        }</span>
        <span class="cov8" title="1">pg.Rows = products

        // count all data
        err = r.db.Model(&amp;Product{}).Count(&amp;totalRows).Error
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Counting products error (repository)", zap.Error(err))
                return &amp;pagination.Pagination{}, err
        }</span>
        <span class="cov8" title="1">pg.TotalRows = int(totalRows)

        // calculate total pages
        pg.TotalPages = int(math.Ceil(float64(totalRows)/float64(pg.Limit))) - 1

        if pg.Page == 0 </span><span class="cov8" title="1">{
                // set from &amp; to row on first page
                fromRow = 1
                toRow = int64(pg.Limit)
        }</span> else<span class="cov8" title="1"> {
                if pg.Page &lt;= pg.TotalPages </span><span class="cov0" title="0">{
                        // calculate from &amp; to row on other pages
                        fromRow = int64(pg.Page*pg.Limit + 1)
                        toRow = int64((pg.Page + 1) * pg.Limit)
                }</span>
        }
        <span class="cov8" title="1">if toRow &gt; totalRows </span><span class="cov8" title="1">{
                //set to row with total rows
                toRow = totalRows
        }</span>
        <span class="cov8" title="1">pg.FromRow = int(fromRow)
        pg.ToRow = int(toRow)

        return pg, nil</span>
}

func (r *repository) Get(id uint) (*Product, error) <span class="cov8" title="1">{
        zap.L().Info("Getting product", zap.Uint("id", id))
        product := &amp;Product{}
        product.ID = id
        err := r.db.First(&amp;product).Error
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Getting product error (repository)", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">return product, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package product

import (
        "fmt"
        "github.com/emreclsr/picusfinal/pagination"
        "go.uber.org/zap"
)

type productService struct {
        repo ProductRepository
}

type ProductService interface {
        Create(product *Product) error
        Search(word string) ([]Product, error)
        Delete(id uint) error
        Update(product *Product) error
        //List() ([]Product, error)
        List(pg *pagination.Pagination) (*pagination.Pagination, error)
        Get(id uint) (*Product, error)
}

func NewProductService(repo ProductRepository) ProductService <span class="cov8" title="1">{
        return &amp;productService{repo: repo}
}</span>

// Compile time proof of interface implementation
var _ ProductService = &amp;productService{}

func (s *productService) Create(product *Product) error <span class="cov8" title="1">{
        zap.L().Info("Create product service triggered")
        err := s.repo.Create(product)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error creating product (service)", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *productService) Search(word string) ([]Product, error) <span class="cov0" title="0">{
        zap.L().Info("Search product service triggered")
        products, err := s.repo.Search(word)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error searching product (service)", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return products, nil</span>
}

func (s *productService) Delete(id uint) error <span class="cov8" title="1">{
        zap.L().Info("Delete product service triggered")
        err := s.repo.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error deleting product (service)", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *productService) Update(product *Product) error <span class="cov8" title="1">{
        zap.L().Info("Update product service triggered")
        err := s.repo.Update(product)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error updating product (service)", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//func (s *productService) List() ([]Product, error) {
//        zap.L().Info("List product service triggered")
//        products, err := s.repo.List()
//        if err != nil {
//                zap.L().Error("Error listing product (service)", zap.Error(err))
//                return nil, err
//        }
//        return products, nil
//}

//type Response struct {
//        Success bool        `json:"success"`
//        Message string      `json:"message"`
//        Data    interface{} `json:"data"`
//}

func (s *productService) List(pg *pagination.Pagination) (*pagination.Pagination, error) <span class="cov8" title="1">{
        operationResult, err := s.repo.List(pg)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var data = operationResult

        //set first &amp; last page pagination response
        data.FirstPage = fmt.Sprintf("%s?limit=%d&amp;page=%d&amp;sort=%s", pg.URLPath, pg.Limit, 0, pg.Sort)
        data.LastPage = fmt.Sprintf("%s?limit=%d&amp;page=%d&amp;sort=%s", pg.URLPath, pg.Limit, pg.TotalPages, pg.Sort)

        if data.Page &gt; 0 </span><span class="cov8" title="1">{
                //set previous page pagination response
                data.PreviousPage = fmt.Sprintf("%s?limit=%d&amp;page=%d&amp;sort=%s", pg.URLPath, pg.Limit, data.Page-1, pg.Sort)
        }</span>
        <span class="cov8" title="1">if data.Page &lt; pg.TotalPages </span><span class="cov0" title="0">{
                //set next page pagination response
                data.NextPage = fmt.Sprintf("%s?limit=%d&amp;page=%d&amp;sort=%s", pg.URLPath, pg.Limit, data.Page+1, pg.Sort)
        }</span>

        <span class="cov8" title="1">if data.Page &gt; pg.TotalPages </span><span class="cov8" title="1">{
                //reset previous page pagination response
                data.PreviousPage = ""
        }</span>
        <span class="cov8" title="1">return data, nil</span>

}

func (s *productService) Get(id uint) (*Product, error) <span class="cov0" title="0">{
        zap.L().Info("Get product service triggered")
        product, err := s.repo.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error getting product (service)", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return product, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package user

import (
        "go.uber.org/zap"
        "gorm.io/gorm"
)

type UserRepository interface {
        Create(user *User) error
        GetByEmail(email string) (*User, error)
        GetByID(id uint) (*User, error)
}

type repository struct {
        db *gorm.DB
}

// Compile time proof of interface implementation
var _ UserRepository = &amp;repository{}

func NewUserRepository(db *gorm.DB) UserRepository <span class="cov8" title="1">{
        return &amp;repository{db: db}
}</span>

func (r *repository) Create(user *User) error <span class="cov8" title="1">{
        zap.L().Debug("Creating user triggered")
        err := r.db.Create(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error creating user", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *repository) GetByEmail(email string) (*User, error) <span class="cov8" title="1">{
        zap.L().Debug("Getting user by email")
        var user User
        err := r.db.Where("email = ?", email).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *repository) GetByID(id uint) (*User, error) <span class="cov8" title="1">{
        zap.L().Debug("Getting user by id")
        var user User
        err := r.db.Where("id = ?", id).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error getting user by id")
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package user

import "go.uber.org/zap"

type userService struct {
        repo UserRepository
}

type UserService interface {
        Create(user *User) error
        GetByEmail(email string) (*User, error)
        GetByID(id uint) (*User, error)
}

// Compile time proof of interface implementation
var _ UserService = &amp;userService{}

func NewUserService(repo UserRepository) UserService <span class="cov0" title="0">{
        return &amp;userService{repo: repo}
}</span>

func (s *userService) Create(user *User) error <span class="cov0" title="0">{
        zap.L().Info("Create user triggered", zap.String("email", user.Email))
        err := s.repo.Create(user)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error creating user", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *userService) GetByEmail(email string) (*User, error) <span class="cov0" title="0">{
        zap.L().Info("Get user by email triggered", zap.String("email", email))
        user, err := s.repo.GetByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                //zap.L().Error("Error getting user by email")
                return nil, err
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (s *userService) GetByID(id uint) (*User, error) <span class="cov0" title="0">{
        zap.L().Info("Get user by id triggered", zap.Uint("id", id))
        user, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error getting user by id", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package user

import (
        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

type User struct {
        gorm.Model
        FullName string `json:"full_name"`
        Email    string `json:"email"`
        Password string `json:"password"`
        Phone    string `json:"phone"`
        Address  string `json:"address"`
        Role     string `json:"role"`
        Status   string `json:"status"`
}

// BeforeCreate will be hashed password before create User
func (u *User) BeforeCreate(tx *gorm.DB) error <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("Error hashing password", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">u.Password = string(hashedPassword)
        return nil</span>
}
</pre>
		
		</div>
	
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>

</body></html>